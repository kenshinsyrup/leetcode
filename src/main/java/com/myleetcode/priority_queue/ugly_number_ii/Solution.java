package com.myleetcode.priority_queue.ugly_number_ii;

import java.util.PriorityQueue;
import java.util.TreeSet;

public class Solution {
    public int nthUglyNumber(int n) {
        return nthUglyNumberByPQ(n);
        // return nthUglyNumberByTreeSet(n);
    }

    /*
    Priority Queue
    https://leetcode.com/problems/ugly-number-ii/discuss/69372/Java-solution-using-PriorityQueue

    Every ugly number must be generated by smaller ugly number mulitiply with ugly factor{2, 3, 5}, so we use this pattern.
    We operate N-1 times(because first operation is special to offer special element 1).
    For each operation i, the fist element in PQ is the ith ugly element, so we poll it out and remove all duplicates, then we could generate new ugly number with ugly factors and push new ugly number into PQ.
    After N-1 operations, the first element in the PQ is the Nth element.

    If don't want to or don't like the Remove duplicats part in PQ, we could also use TreeSet, which give us same TC and SC. BUT priority queue is more common and its API easier in interview.

    TC: O(N*logN)
    SC: O(N)
    */
    private int nthUglyNumberByPQ(int N) {
        if (N <= 0) {
            return 0;
        }

        PriorityQueue<Long> uglyPQ = new PriorityQueue<>();
        uglyPQ.offer(1L); // Offer the special first element in at start.

        int[] uglyFactors = new int[]{2, 3, 5};
        for (int i = 1; i < N; i++) { // we need 1:n operations, since we have already offer(1) so we need another 1:n-1 operations
            long uglyNum = uglyPQ.poll();

            // Remove duplicates before generate new ugly number.
            while (!uglyPQ.isEmpty() && uglyPQ.peek() == uglyNum) {
                uglyPQ.poll();
            }

            for (int factor : uglyFactors) {
                uglyPQ.offer(uglyNum * factor);
            }
        }

        return uglyPQ.poll().intValue();

    }

    private int nthUglyNumberByTreeSet(int N) {
        if (N <= 0) {
            return 0;
        }

        TreeSet<Long> uglyTreeSet = new TreeSet<>();
        uglyTreeSet.add(1L);

        int[] uglyFactors = new int[]{2, 3, 5};
        for (int i = 1; i < N; i++) {
            long uglyNum = uglyTreeSet.pollFirst(); // first() is peek, pollFirst is poll, here need poll.

            for (int factor : uglyFactors) {
                uglyTreeSet.add(uglyNum * factor);
            }
        }

        return uglyTreeSet.pollFirst().intValue();
    }
}
